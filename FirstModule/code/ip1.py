# -*- coding: utf-8 -*-
"""IP1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H1ZNKP5-u5aDWLJQjRWPBpOYRoVHiGrO

T1.1
"""

from PIL import Image # Imports the Python Imaging Library for image processing
import numpy as np # Imports NumPy for numerical operations, especially for array manipulations
import matplotlib.pyplot as plt # Imports Matplotlib for plotting and image display

# Load the image (replace 'T1.1.jpg' with the actual image path)
image = Image.open('T1.1.jpg').convert('L')  # Convert to grayscale ('L' mode)
image_array = np.array(image) # Convert the image to a NumPy array

# Calculate the negative image
L = 256  # Maximum intensity level for 8-bit images (0-255)
negative_image = L - 1 - image_array # Formula for negative image: (L-1) - pixel value

# Convert back to an image and display
negative_image = Image.fromarray(negative_image.astype('uint8')) # Convert array back to image

# Display the original and negative images
plt.figure(figsize=(10,5)) # Create a figure with specific size

plt.subplot(1, 2, 1) # Create a subplot (1 row, 2 columns, this is the 1st subplot)
plt.title('Original Image') # Set title for the subplot
plt.imshow(image, cmap='gray') # Display the image in grayscale

plt.subplot(1, 2, 2) # Create the 2nd subplot
plt.title('Negative Image') # Set title for the subplot
plt.imshow(negative_image, cmap='gray') # Display the negative image in grayscale

plt.show() # Show the figure with both subplots

"""T1.2"""

from PIL import Image # Imports the Python Imaging Library for image processing
import numpy as np # Imports NumPy for numerical operations, especially for array manipulations
import matplotlib.pyplot as plt # Imports Matplotlib for plotting and image display

# Load the image
image = Image.open('T1.2.jpg').convert('L')  # Convert to grayscale ('L' mode)
image_array = np.array(image) # Convert the PIL Image to a NumPy array

# Calculate the constant c
c = 255 / np.log(1 + np.max(image_array)) # Formula to determine the constant for log transformation

# Apply the logarithmic transformation
log_image = c * np.log(1 + image_array) # Applying the transformation to each pixel

# Normalize the image to a valid range [0, 255]
log_image = np.array(log_image, dtype=np.uint8) # Convert to 8-bit unsigned integer

# Convert back to image and display
log_image_pil = Image.fromarray(log_image) # Convert NumPy array back to a PIL Image

# Display the original and logarithmic images
plt.figure(figsize=(10, 5)) # Create a Matplotlib figure with specified size

plt.subplot(1, 2, 1) # Create a subplot (1 row, 2 columns, this is the 1st subplot)
plt.title('Original Image') # Set the title for the 1st subplot
plt.imshow(image, cmap='gray') # Display the original image in grayscale

plt.subplot(1, 2, 2) # Create the 2nd subplot
plt.title('Image with Logarithmic Transformation') # Set the title for the 2nd subplot
plt.imshow(log_image_pil, cmap='gray') # Display the log-transformed image in grayscale

plt.show() # Show the figure with both subplots

"""T1.3a"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image = Image.open('T1.3a.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Normalize the image
image_normalized = image_array / 255.0

# Define the gamma value (you can adjust it as needed)
gamma = 2.2  # You can try other values like 0.5, 1.5, etc.

# Apply gamma correction
gamma_corrected = np.power(image_normalized, gamma)

# Scale back to [0, 255]
gamma_corrected = np.uint8(gamma_corrected * 255)

# Convert back to image and display
gamma_image = Image.fromarray(gamma_corrected)

# Display the original and gamma-corrected images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

plt.subplot(1, 2, 2)
plt.title(f'Gamma Corrected Image (gamma={gamma})')
plt.imshow(gamma_image, cmap='gray')

plt.show()

"""T1.3b"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image = Image.open('T1.3b.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Normalize the image
image_normalized = image_array / 255.0

# Define the gamma value (you can adjust it as needed)
gamma = 0.5  # Use a lower value to see the brightening effect

# Apply gamma correction
gamma_corrected = np.power(image_normalized, gamma)

# Scale back to [0, 255]
gamma_corrected = np.uint8(gamma_corrected * 255)

# Convert back to image and display
gamma_image = Image.fromarray(gamma_corrected)

# Display the original and gamma-corrected images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

plt.subplot(1, 2, 2)
plt.title(f'Gamma Corrected Image (gamma={gamma})')
plt.imshow(gamma_image, cmap='gray')

plt.show()

"""T1.4"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image = Image.open('T1.4.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Find the minimum and maximum intensity values in the image
I_min = np.min(image_array)
I_max = np.max(image_array)

# Apply contrast stretching
L = 256  # For 8-bit images
stretched_image = (image_array - I_min) / (I_max - I_min) * (L - 1)

# Convert back to an 8-bit image
stretched_image = np.uint8(stretched_image)

# Convert back to PIL image and display
stretched_image_pil = Image.fromarray(stretched_image)

# Display the original and contrast-stretched images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

plt.subplot(1, 2, 2)
plt.title('Contrast-Stretched Image')
plt.imshow(stretched_image_pil, cmap='gray')

plt.show()

"""T1.5"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image = Image.open('T1.5.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Define the intensity range you want to highlight
I_min = 100  # Lower limit of the range
I_max = 200  # Upper limit of the range

# Apply intensity slicing transformation
sliced_image = np.where((image_array >= I_min) & (image_array <= I_max), image_array, 0)

# Convert back to image and display
sliced_image_pil = Image.fromarray(sliced_image.astype('uint8'))

# Display the original and sliced images
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

plt.subplot(1, 2, 2)
plt.title(f'Sliced Image ({I_min}-{I_max})')
plt.imshow(sliced_image_pil, cmap='gray')

plt.show()

"""T1.6"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image = Image.open('T1.6.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Function to extract bit planes
def extract_bit_plane(image_array, bit_position):
    return np.bitwise_and(image_array, 1 << bit_position) >> bit_position

# Create a figure to display all the bit planes
plt.figure(figsize=(12, 8))

# Extract and display the bit planes (from 0 to 7)
for i in range(8):
    bit_plane = extract_bit_plane(image_array, i)

    plt.subplot(2, 4, i+1)
    plt.title(f'Bit Plane {i}')
    plt.imshow(bit_plane, cmap='gray')
    plt.axis('off')

plt.tight_layout()
plt.show()

"""T2.1"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Load the image
image = Image.open('T1.4.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Function to calculate the histogram
def calculate_histogram(image_array):
    histogram = np.zeros(256, dtype=int)  # Initialize an array of zeros of size 256

    # Iterate through each pixel in the image and increment the histogram counter
    for pixel_value in image_array.flatten():
        histogram[pixel_value] += 1

    return histogram

# Calculate the histogram of the image
histogram = calculate_histogram(image_array)

# Visualize the histogram
plt.figure(figsize=(10, 5))
plt.title('Image Histogram')
plt.bar(range(256), histogram, width=1, color='gray')
plt.xlabel('Intensity Value')
plt.ylabel('Frequency')
plt.show()

"""T2.2"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Function to calculate the histogram (from task T2.1)
def calculate_histogram(image_array):
    histogram = np.zeros(256, dtype=int)  # Initialize an array of zeros of size 256

    # Iterate through each pixel in the image and increment the histogram counter
    for pixel_value in image_array.flatten():
        histogram[pixel_value] += 1

    return histogram

# Function to display the histogram
def display_histogram(histogram, title):
    plt.figure(figsize=(10, 5))
    plt.title(title)
    plt.bar(range(256), histogram, width=1, color='gray')
    plt.xlabel('Intensity Value')
    plt.ylabel('Frequency')
    plt.show()

# Let's assume you've already applied the transformations from T1.1 to T1.6
# Load the resulting images from the transformations
transformed_images = {
    "Negative (T1.1)": 'T1.1.jpg',
    "Logarithmic (T1.2)": 'T1.2.jpg',
    "Gamma (T1.3a)": 'T1.3a.jpg',
    "Gamma (T1.3b)": 'T1.3b.jpg',
    "Contrast Stretching (T1.4)": 'T1.4.jpg',
    "Intensity Slicing (T1.5)": 'T1.5.jpg',
    "Bit Planes (T1.6)": 'T1.6.jpg'  # Could be one of the planes, depending on the choice
}

# Calculate and display the histograms for each image
for title, image_path in transformed_images.items():
    # Load the transformed image
    image = Image.open(image_path).convert('L')  # Convert to grayscale
    image_array = np.array(image)

    # Calculate the histogram
    histogram = calculate_histogram(image_array)

    # Display the histogram
    display_histogram(histogram, f'Histogram of {title}')

"""T2.3"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

# Function to calculate the histogram (from task T2.1)
def calculate_histogram(image_array):
    histogram = np.zeros(256, dtype=int)  # Initialize an array of zeros of size 256
    for pixel_value in image_array.flatten():
        histogram[pixel_value] += 1
    return histogram

# Function to equalize the histogram
def equalize_histogram(image_array):
    # Calculate the histogram
    histogram = calculate_histogram(image_array)

    # Calculate the cumulative distribution function (CDF)
    cdf = histogram.cumsum()  # Cumulative sum
    cdf_normalized = (cdf - cdf.min()) * 255 / (cdf.max() - cdf.min())  # Normalize the CDF

    # Apply histogram equalization
    equalized_image = np.interp(image_array.flatten(), range(256), cdf_normalized)  # Interpolation
    equalized_image = equalized_image.reshape(image_array.shape).astype('uint8')  # Reshape

    return equalized_image

# Load the original image
image = Image.open('T1.4.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Apply histogram equalization
equalized_image = equalize_histogram(image_array)

# Convert the equalized image back to PIL format
equalized_image_pil = Image.fromarray(equalized_image)

# Display the original and equalized images
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

plt.subplot(1, 2, 2)
plt.title('Equalized Image')
plt.imshow(equalized_image_pil, cmap='gray')

plt.show()

# Display the histograms of the original and equalized images
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
plt.title('Original Image Histogram')
hist_original = calculate_histogram(image_array)
plt.bar(range(256), hist_original, width=1, color='gray')

plt.subplot(1, 2, 2)
plt.title('Equalized Image Histogram')
hist_equalized = calculate_histogram(equalized_image)
plt.bar(range(256), hist_equalized, width=1, color='gray')

plt.show()

"""T3.1a"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import convolve

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1a.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Function to create a box kernel of size NxN
def create_box_kernel(size):
    return np.ones((size, size)) / (size * size)

# Apply low-pass filtering with different kernel sizes
kernels = [3, 11, 21]
smoothed_images = []

for kernel_size in kernels:
    kernel = create_box_kernel(kernel_size)
    smoothed_image = convolve(image_array, kernel)
    smoothed_images.append(smoothed_image)

# Visualize the original image and the smoothed images
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, kernel_size in enumerate(kernels):
    plt.subplot(2, 2, i+2)
    plt.title(f'Box Filter {kernel_size}x{kernel_size}')
    plt.imshow(smoothed_images[i], cmap='gray')

plt.show()

"""T3.1b"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import convolve

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1b.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Function to create a box kernel of size NxN
def create_box_kernel(size):
    return np.ones((size, size)) / (size * size)

# Apply low-pass filtering with different kernel sizes
kernels = [3, 11, 21]
smoothed_images = []

for kernel_size in kernels:
    kernel = create_box_kernel(kernel_size)
    smoothed_image = convolve(image_array, kernel)
    smoothed_images.append(smoothed_image)

# Visualize the original image and the smoothed images
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, kernel_size in enumerate(kernels):
    plt.subplot(2, 2, i+2)
    plt.title(f'Box Filter {kernel_size}x{kernel_size}')
    plt.imshow(smoothed_images[i], cmap='gray')

plt.show()

"""T3.1c"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import convolve

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1c.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Function to create a box kernel of size NxN
def create_box_kernel(size):
    return np.ones((size, size)) / (size * size)

# Apply low-pass filtering with different kernel sizes
kernels = [3, 11, 21]
smoothed_images = []

for kernel_size in kernels:
    kernel = create_box_kernel(kernel_size)
    smoothed_image = convolve(image_array, kernel)
    smoothed_images.append(smoothed_image)

# Visualize the original image and the smoothed images
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, kernel_size in enumerate(kernels):
    plt.subplot(2, 2, i+2)
    plt.title(f'Box Filter {kernel_size}x{kernel_size}')
    plt.imshow(smoothed_images[i], cmap='gray')

plt.show()

"""T3.1d"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import convolve

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1d.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Function to create a box kernel of size NxN
def create_box_kernel(size):
    return np.ones((size, size)) / (size * size)

# Apply low-pass filtering with different kernel sizes
kernels = [3, 11, 21]
smoothed_images = []

for kernel_size in kernels:
    kernel = create_box_kernel(kernel_size)
    smoothed_image = convolve(image_array, kernel)
    smoothed_images.append(smoothed_image)

# Visualize the original image and the smoothed images
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, kernel_size in enumerate(kernels):
    plt.subplot(2, 2, i+2)
    plt.title(f'Box Filter {kernel_size}x{kernel_size}')
    plt.imshow(smoothed_images[i], cmap='gray')

plt.show()

"""T3.2a"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1a.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Define the standard deviations for the Gaussian filters
sigmas = [1, 5, 10]

# Apply Gaussian filtering with different standard deviations (sigma)
gaussian_images = []
for sigma in sigmas:
    gaussian_image = gaussian_filter(image_array, sigma=sigma)
    gaussian_images.append(gaussian_image)

# Visualize the original image and the smoothed images with the Gaussian filter
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, sigma in enumerate(sigmas):
    plt.subplot(2, 2, i+2)
    plt.title(f'Gaussian Filter (sigma={sigma})')
    plt.imshow(gaussian_images[i], cmap='gray')

plt.show()

"""T3.2b"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1b.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Define the standard deviations for the Gaussian filters
sigmas = [1, 5, 10]

# Apply Gaussian filtering with different standard deviations (sigma)
gaussian_images = []
for sigma in sigmas:
    gaussian_image = gaussian_filter(image_array, sigma=sigma)
    gaussian_images.append(gaussian_image)

# Visualize the original image and the smoothed images with the Gaussian filter
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, sigma in enumerate(sigmas):
    plt.subplot(2, 2, i+2)
    plt.title(f'Gaussian Filter (sigma={sigma})')
    plt.imshow(gaussian_images[i], cmap='gray')

plt.show()

"""T3.2c"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1c.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Define the standard deviations for the Gaussian filters
sigmas = [1, 5, 10]

# Apply Gaussian filtering with different standard deviations (sigma)
gaussian_images = []
for sigma in sigmas:
    gaussian_image = gaussian_filter(image_array, sigma=sigma)
    gaussian_images.append(gaussian_image)

# Visualize the original image and the smoothed images with the Gaussian filter
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, sigma in enumerate(sigmas):
    plt.subplot(2, 2, i+2)
    plt.title(f'Gaussian Filter (sigma={sigma})')
    plt.imshow(gaussian_images[i], cmap='gray')

plt.show()

"""T3.2d"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1d.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Define the standard deviations for the Gaussian filters
sigmas = [1, 5, 10]

# Apply Gaussian filtering with different standard deviations (sigma)
gaussian_images = []
for sigma in sigmas:
    gaussian_image = gaussian_filter(image_array, sigma=sigma)
    gaussian_images.append(gaussian_image)

# Visualize the original image and the smoothed images with the Gaussian filter
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, sigma in enumerate(sigmas):
    plt.subplot(2, 2, i+2)
    plt.title(f'Gaussian Filter (sigma={sigma})')
    plt.imshow(gaussian_images[i], cmap='gray')

plt.show()

"""T3.3a"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import median_filter

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1b.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Define the kernel sizes for the median filtering
kernel_sizes = [3, 5, 9]

# Apply median filtering with different kernel sizes
median_images = []
for kernel_size in kernel_sizes:
    median_image = median_filter(image_array, size=kernel_size)
    median_images.append(median_image)

# Visualize the original image and the images with median filtering
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, kernel_size in enumerate(kernel_sizes):
    plt.subplot(2, 2, i+2)
    plt.title(f'Median Filter {kernel_size}x{kernel_size}')
    plt.imshow(median_images[i], cmap='gray')

plt.show()

"""T3.3b"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import median_filter

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1c.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Define the kernel sizes for the median filtering
kernel_sizes = [3, 5, 9]

# Apply median filtering with different kernel sizes
median_images = []
for kernel_size in kernel_sizes:
    median_image = median_filter(image_array, size=kernel_size)
    median_images.append(median_image)

# Visualize the original image and the images with median filtering
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, kernel_size in enumerate(kernel_sizes):
    plt.subplot(2, 2, i+2)
    plt.title(f'Median Filter {kernel_size}x{kernel_size}')
    plt.imshow(median_images[i], cmap='gray')

plt.show()

"""T3.3c"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import median_filter

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1d.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Define the kernel sizes for the median filtering
kernel_sizes = [3, 5, 9]

# Apply median filtering with different kernel sizes
median_images = []
for kernel_size in kernel_sizes:
    median_image = median_filter(image_array, size=kernel_size)
    median_images.append(median_image)

# Visualize the original image and the images with median filtering
plt.figure(figsize=(15, 10))

plt.subplot(2, 2, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

for i, kernel_size in enumerate(kernel_sizes):
    plt.subplot(2, 2, i+2)
    plt.title(f'Median Filter {kernel_size}x{kernel_size}')
    plt.imshow(median_images[i], cmap='gray')

plt.show()

"""T3.4a"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import sobel, prewitt, laplace
from skimage.filters import roberts

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1a.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Apply Sobel operators (first derivative)
sobel_x = sobel(image_array, axis=0)  # Derivative in the X direction
sobel_y = sobel(image_array, axis=1)  # Derivative in the Y direction
sobel_total = np.hypot(sobel_x, sobel_y)  # Gradient magnitude

# Apply Prewitt operators (first derivative)
prewitt_x = prewitt(image_array, axis=0)  # Derivative in the X direction
prewitt_y = prewitt(image_array, axis=1)  # Derivative in the Y direction
prewitt_total = np.hypot(prewitt_x, prewitt_y)  # Gradient magnitude

# Apply Roberts operator (first derivative)
roberts_total = roberts(image_array)

# Apply Laplacian operator (second derivative)
laplacian_total = laplace(image_array)

# Visualize the results
plt.figure(figsize=(15, 10))

plt.subplot(2, 3, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

plt.subplot(2, 3, 2)
plt.title('Sobel')
plt.imshow(sobel_total, cmap='gray')

plt.subplot(2, 3, 3)
plt.title('Prewitt')
plt.imshow(prewitt_total, cmap='gray')

plt.subplot(2, 3, 4)
plt.title('Roberts')
plt.imshow(roberts_total, cmap='gray')

plt.subplot(2, 3, 5)
plt.title('Laplacian')
plt.imshow(laplacian_total, cmap='gray')

plt.tight_layout()
plt.show()

"""T3.4b"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import sobel, prewitt, laplace
from skimage.filters import roberts

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1b.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Apply Sobel operators (first derivative)
sobel_x = sobel(image_array, axis=0)  # Derivative in the X direction
sobel_y = sobel(image_array, axis=1)  # Derivative in the Y direction
sobel_total = np.hypot(sobel_x, sobel_y)  # Gradient magnitude

# Apply Prewitt operators (first derivative)
prewitt_x = prewitt(image_array, axis=0)  # Derivative in the X direction
prewitt_y = prewitt(image_array, axis=1)  # Derivative in the Y direction
prewitt_total = np.hypot(prewitt_x, prewitt_y)  # Gradient magnitude

# Apply Roberts operator (first derivative)
roberts_total = roberts(image_array)

# Apply Laplacian operator (second derivative)
laplacian_total = laplace(image_array)

# Visualize the results
plt.figure(figsize=(15, 10))

plt.subplot(2, 3, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

plt.subplot(2, 3, 2)
plt.title('Sobel')
plt.imshow(sobel_total, cmap='gray')

plt.subplot(2, 3, 3)
plt.title('Prewitt')
plt.imshow(prewitt_total, cmap='gray')

plt.subplot(2, 3, 4)
plt.title('Roberts')
plt.imshow(roberts_total, cmap='gray')

plt.subplot(2, 3, 5)
plt.title('Laplacian')
plt.imshow(laplacian_total, cmap='gray')

plt.tight_layout()
plt.show()

"""T3.4c"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import sobel, prewitt, laplace
from skimage.filters import roberts

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1c.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Apply Sobel operators (first derivative)
sobel_x = sobel(image_array, axis=0)  # Derivative in the X direction
sobel_y = sobel(image_array, axis=1)  # Derivative in the Y direction
sobel_total = np.hypot(sobel_x, sobel_y)  # Gradient magnitude

# Apply Prewitt operators (first derivative)
prewitt_x = prewitt(image_array, axis=0)  # Derivative in the X direction
prewitt_y = prewitt(image_array, axis=1)  # Derivative in the Y direction
prewitt_total = np.hypot(prewitt_x, prewitt_y)  # Gradient magnitude

# Apply Roberts operator (first derivative)
roberts_total = roberts(image_array)

# Apply Laplacian operator (second derivative)
laplacian_total = laplace(image_array)

# Visualize the results
plt.figure(figsize=(15, 10))

plt.subplot(2, 3, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

plt.subplot(2, 3, 2)
plt.title('Sobel')
plt.imshow(sobel_total, cmap='gray')

plt.subplot(2, 3, 3)
plt.title('Prewitt')
plt.imshow(prewitt_total, cmap='gray')

plt.subplot(2, 3, 4)
plt.title('Roberts')
plt.imshow(roberts_total, cmap='gray')

plt.subplot(2, 3, 5)
plt.title('Laplacian')
plt.imshow(laplacian_total, cmap='gray')

plt.tight_layout()
plt.show()

"""T3.4d"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import sobel, prewitt, laplace
from skimage.filters import roberts

# Load the image (you can change the path based on the image you want to test)
image = Image.open('T3.1d.jpg').convert('L')  # Convert to grayscale
image_array = np.array(image)

# Apply Sobel operators (first derivative)
sobel_x = sobel(image_array, axis=0)  # Derivative in the X direction
sobel_y = sobel(image_array, axis=1)  # Derivative in the Y direction
sobel_total = np.hypot(sobel_x, sobel_y)  # Gradient magnitude

# Apply Prewitt operators (first derivative)
prewitt_x = prewitt(image_array, axis=0)  # Derivative in the X direction
prewitt_y = prewitt(image_array, axis=1)  # Derivative in the Y direction
prewitt_total = np.hypot(prewitt_x, prewitt_y)  # Gradient magnitude

# Apply Roberts operator (first derivative)
roberts_total = roberts(image_array)

# Apply Laplacian operator (second derivative)
laplacian_total = laplace(image_array)

# Visualize the results
plt.figure(figsize=(15, 10))

plt.subplot(2, 3, 1)
plt.title('Original Image')
plt.imshow(image, cmap='gray')

plt.subplot(2, 3, 2)
plt.title('Sobel')
plt.imshow(sobel_total, cmap='gray')

plt.subplot(2, 3, 3)
plt.title('Prewitt')
plt.imshow(prewitt_total, cmap='gray')

plt.subplot(2, 3, 4)
plt.title('Roberts')
plt.imshow(roberts_total, cmap='gray')

plt.subplot(2, 3, 5)
plt.title('Laplacian')
plt.imshow(laplacian_total, cmap='gray')

plt.tight_layout()
plt.show()